[{"categories":["写作"],"content":"优良传统，先写一个 Hello world： package main import \"fmt\" func main() { fmt.Println(\"Hello World\") } ","date":"2022-10-30","objectID":"/reboot/:0:0","tags":["Go"],"title":"#Reboot：重新写博客了！🥳","uri":"/reboot/"},{"categories":null,"content":"🥁 终身学习者 🚀 关注大前端，AI，Web3，新商业世界 😆 INTJ \u0026 产品经理，独立开发者，Bug 制造者 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"施工中","uri":"/about/"},{"categories":["碎碎念"],"content":"宇宙是口锅，星辰是元宵 我是在白雪国生活的黑芝麻人 即使漂浮在锅口，即使沉没在锅底 有时候，还是想成为… 天上那轮半明半暗的黄色小船🌛 ","date":"2018-03-02","objectID":"/happy-lantern-festival/:0:0","tags":["日常"],"title":"2018元宵节快乐！🥳","uri":"/happy-lantern-festival/"},{"categories":["编程"],"content":"1.使用canvas元素 在HTML页面上定义\u003ccanvas...\u003e元素与定义其他普通元素并无任何不同，它除了可以指定id、style、class、hidden等通用属性之外，还可以指定如下两个属性： height：该属性设置该画布组件高度 width：该属性设置该画布组件宽度 在HTML网页上定义\u003ccanvas.../\u003e元素，它只是一张“空白”的画布。为了在\u003ccanvas.../\u003e元素上绘图，必须经过如下3步： 获取\u003ccanvas.../\u003e元素对应的DOM对象，这是一个Canvas对象 调用Canvas对象的getContent()方法，该方法返回一个CanvasRenderingContext2D对象，该对象即可绘制图形。 调用CanvasRendingContext2D对象的方法绘图。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ecanvas\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch2\u003e画图入门\u003c/h2\u003e \u003ccanvas id=\"mc\" width=\"300\" height=\"180\" style=\"border: 1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); // 设置填充颜色 ctx.fillStyle = '#f00'; // 绘制矩形 ctx.fillRect(30,40,80,100); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2016-09-02","objectID":"/html-canvas-study/:1:0","tags":["前端","HTML5"],"title":"HTML5 Canvas学习笔记","uri":"/html-canvas-study/"},{"categories":["编程"],"content":"2.绘制几何图形 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003erect\u003c/title\u003e \u003ch2\u003e绘制图形\u003c/h2\u003e \u003ccanvas id =\"mc\" width=\"400\" height=\"280\" style=\"boreder:1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); // 设置填充颜色 ctx.fillStyle = '#f00'; // 填充一个矩形 ctx.fillRect(30,20,120,60); // 设置填充颜色 ctx.fillStyle = '#ff0'; // 填充一个矩形 ctx.fillRect(80,60,120,60); // 设置线条颜色 ctx.strokeStyle = \"#00f\"; // 设置线条宽度 ctx.lineWidth = 10; // 绘制一个矩形边框 ctx.strokeRect(30,130,120,60); // 设置线条颜色 ctx.strokeStyle = '#0ff'; // 设置线条宽度 ctx.lineJoin = 'round'; // 绘制一个矩形边框 ctx.strokeRect(80,160,120,60); // 设置线条颜色 ctx.strokeStyle = '#f0f'; // 设置线条宽度 ctx.lineJoin = 'bevel'; // 绘制一个矩形边框 ctx.strokeRect(130,190,120,60); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2016-09-02","objectID":"/html-canvas-study/:2:0","tags":["前端","HTML5"],"title":"HTML5 Canvas学习笔记","uri":"/html-canvas-study/"},{"categories":["编程"],"content":"3.绘制字符串 CanvasRenderingContext2D为绘制文字提供了如下两个方法： fillText(String text,float x,float y,[float maxWidth])：填充字符串 stroke(String text,float x,float y,[float maxWidth]):绘制字符串边框 为了设置绘制字符串时所用的字体、字体对齐方式，CanvasRenderingContext2D还提供了如下两个属性： textAlign：该属性支持start、end、left、right、center等属性值。 textBaseAlign：设置绘制字符串的垂直对齐方式，该属性支持top、hanging、middle、alphabetic、idecgraphic、bottom等属性值。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e绘制文字\u003c/title\u003e \u003ch2\u003e绘制文字\u003c/h2\u003e \u003ccanvas id= \"mc\" width=\"600\" height=\"280\" style=\"border: 1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type= \"text/javascript\"\u003e // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); ctx.fillStyle = '00f'; ctx.font = 'italic 50px 隶书'; ctx.textBaseline = 'top'; // 填充字符串 ctx.fillText('填充文字',0,0); ctx.strokeStyle = '#f0f'; ctx.font = 'bold 45px 宋体'; // 绘制字符串的边框 ctx.strokeText('Canvas绘制文字边框',0,50); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2016-09-02","objectID":"/html-canvas-study/:3:0","tags":["前端","HTML5"],"title":"HTML5 Canvas学习笔记","uri":"/html-canvas-study/"},{"categories":["编程"],"content":"4. 设置阴影 CanvasRenderingContext2D为设置图形阴影提供了如下属性： shadowBlur：设置阴影的模糊度。该属性值是一个浮点数，该数值越大。阴影的模糊程度就越大。 shadowColor：设置阴影的颜色。 shadowOffsetX：设置阴影在X方向的偏移。 shadowOffsetY：设置阴影在Y方向的偏移。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e启用阴影\u003c/title\u003e \u003ch2\u003e启用阴影\u003c/h2\u003e \u003ccanvas id=\"mc\" width=\"600\" height=\"280\" style=\"border: 1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); // 设置阴影的模糊度 ctx.shadowBlur = 5.6; // 设置阴影的颜色 ctx.shadowColor = '#222'; // 设置阴影在X、Y方向的偏移 ctx.shadowOffsetX = 10; ctx.shadowOffsetY = -6; ctx.font = 'italic 50px 隶书'; ctx.textBaseline = 'top'; // 填充字符串 ctx.fillText('绘制阴影',0,0); ctx.strokeStyle = '#f0f'; ctx.font = 'bold 45px 宋体'; // 绘制字符串的边框 ctx.strokeText('绘制阴影',0,50); // 填充一个矩形区域 ctx.fillRect(20,150,180,80); // 绘制一个矩形边框 ctx.strokeRect(300,150,180,80); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2016-09-02","objectID":"/html-canvas-study/:4:0","tags":["前端","HTML5"],"title":"HTML5 Canvas学习笔记","uri":"/html-canvas-study/"},{"categories":["编程"],"content":"5.使用路径 CanvasRenderingContext2D并没有直接提供绘制图形、椭圆等几何图形的方法。为了在Canvas上绘制更复杂的图形，必须在Canvas上启用路径，借助于路径来绘制图形。 在Canvas上使用路径，可按如下步骤进行： 调用CanvasRenderingContext2D对象的beginPath()方法开始定义路径。 调用CanvasRenderingContext2D各种方法添加子路径。 调用CanvasRenderingContext2D的closePath()方法关闭子路径。 调用CanvasRenderingContext2D的fill()或stroke()方法来填充路径或绘制路径边框。 CanvasRenderingContext2D对象提供了如下方法来添加子路径： arc(float x,float y,float radius,float startAngle,endAngle,boolean counterclockwise)：向Canvas的当前路径上添加一段弧。绘制以x、y为圆心，radius为半径，从startAngle角度开始，到endAngle角度结束的圆弧。startAngle、endAngle以弧度为单位。该方法的前两个参数指定圆弧的圆心，第三个参数用于设置圆弧的半径，第四、五个参数则用于设置圆弧的开始角度、结束角度，最后一个角度用于设置是否顺时针旋转。 arcTo(float x1,float y1,float x2,float y2,float radius)：向Canvas的当前路径上添加一段弧。与前一个方法相比，只是定义\u0008\u0008弧的方式不同。该方法也是绘制一段圆弧，确定这段圆弧的方式是：假设从当前点到 P1(x1,y1)绘制一条线条，再从P1(x1,y1)到P2(x2,y2) 绘制一条线条，arcTo()则绘制一段同时与上面两条线条相切，且半径为radius的圆弧。 bezierCurveTo(float cpX1,float cpY1,float cpX2,float cpY2,float x,float y):向Canvas的当前路径上添加一段贝济埃曲线。 lineTo(float x,float y):把Canvas的当前路径从当前结束点连接到x、y对应的点。 moveTo(float x,float y):把Canvas的当前路径的结束点移动到x、y对应的点。 quadraticCurveTo(float cpX,float cpY,float x,float y):向Canvas添加一段二次曲线。 rect(float x,float y,float width,float height):向Canvas的当前路径添加一个矩形。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e绘制圆形\u003c/title\u003e \u003ch2\u003e绘制圆形\u003c/h2\u003e \u003ccanvas id=\"mc\" width=\"400\" height=\"280\" style=\"border: 1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e // 获取canva元素对应的DOM对象 var canvas = document.getElementById(\"mc\"); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); for(var i = 0;i \u003c 10;i++){ // 开始定义路径 ctx.beginPath(); // 添加一段圆弧 ctx.arc(i * 25,i * 25,(i + 1) * 8,0, Math.PI * 2 ,true); // 关闭路径 ctx.closePath(); // 设置填充颜色 ctx.fillStyle = 'rgba(255,0,255,'+(10-i)*0.1+')'; // 填充当前路径 ctx.fill(); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 使用arcTo()方法绘制一个圆角\u0008矩形。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003earcTo示例\u003c/title\u003e \u003ch2\u003e arcTo 示意\u003c/h2\u003e \u003ccanvas id = 'mc' width = '400' height=\"280\" style=\"border: 1px solid black\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e /* 该方法负责绘制圆角矩形 x1、y1:圆角矩形左上角的坐标 width、height:控制圆角矩形的宽、高 radius:控制圆角矩形的四个圆角的半径 */ function createRoundRect(ctx, x1, y1, width, height, radius) { // 移动到左上角 ctx.moveTo(x1 + radius,y1); // 添加一条连接到右上角的线段 ctx.lineTo(x1 + width - radius,y1); // 添加一段圆弧 ctx.arcTo(x1 + width, y1, x1 + width, y1 + radius, radius); // 添加一条连接到右下角的线段 ctx.lineTo(x1 + width, y1 + height - radius); // 添加一段圆弧 ctx.arcTo(x1 + width, y1 + height, x1 + width - radius, y1 + height, radius); // 添加一条连接到左下角的线段 ctx.lineTo(x1 + radius, y1 + height); // 添加一段圆弧 ctx.arcTo(x1, y1 + height, x1, y1 + height - radius, radius); // 添加一条连接到左上角的线段 ctx.lineTo(x1,y1 + radius); //添加一段圆弧 ctx.arcTo(x1, y1, x1 + radius, y1, radius); ctx.closePath(); } // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContex2D对象 var ctx = canvas.getContext('2d'); ctx.lineWidth = 3; createRoundRect(ctx, 30, 30, 200, 100, 20); ctx.stroke(); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 其中moveTo(x,y)和`lineToo(x,y)，前者是把绘制点移动到指定点，而后者则负责绘制从当前点到指定点(x,y)的线条。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elineTo示例\u003c/title\u003e \u003ch2\u003elineTo示例\u003c/h2\u003e \u003ccanvas id = \"mc\" width = \"500\" height=\"380\" style=\"border: 1px solid black;\"\u003e\u003c/canvas\u003e \u003cscript type=\"text/javascript\"\u003e /* 该方法负责绘制多角星 n: 该参数通常应设为奇数,控制绘制N角星 dx、dy: 控制N角星的位置 size: 控制N角星的大小 */ function createStar(context, n, dx, dy, size) { // 开始创建路径 context.beginPath(); var dig = Math.PI / n * 4; context.moveTo(dx, y + dy); for(var i = 0; i \u003c n; i++) { var x = Math.sin(i * dig); var y = Math.cos(i * dig); // 绘制从当前点连接到指定点的线条 context.lineTo(x * size + dx, y * size + dy); } // 关闭路径 context.closePath(); } // 获取canvas元素对应的DOM对象 var canvas = document.getElementById('mc'); // 获取在canvas上绘图的CanvasRenderingContext2D对象 var ctx = canvas.getContext('2d'); // 绘制3角星 createStar(ctx, 3, 60, 60, 50); ctx.fillStyle = '#f00'; ctx.fill(); // 绘制5角星 createStar(ctx, 5, 160, 60, 50); ctx.fillStyle = '#0f0'; ctx.fill(); // 绘制7角星 createStar(","date":"2016-09-02","objectID":"/html-canvas-study/:5:0","tags":["前端","HTML5"],"title":"HTML5 Canvas学习笔记","uri":"/html-canvas-study/"},{"categories":["专业学习"],"content":"概述 计算传播学作为一门跨领域和交叉性较强的新兴学科，可以借助复杂网络理论和社会计算等研究方法，再现信息传播的演化过程，建立信息传播和扩散模型的演化和动态过程仿真，挖掘数据和传播模态背后的深刻联系。 ","date":"2016-04-25","objectID":"/computational-communication/:1:0","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"1.研究背景 ","date":"2016-04-25","objectID":"/computational-communication/:2:0","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"1.1 学科发展历史 计算传播学（computational communication research）是计算社会科学（computational social science）的重要分支。目前，计算社会科学已经在各个分支学科和新的交叉性学科中如火如荼。作为国际上正在形成中的计算社会科学(computational social science，简称CSS)一大分支，计算传播学涉及领域广泛，包括但并不局限于如新闻与信息扩散研究，社会化媒体的采纳、使用与效果研究，社会网中的媒体行为与人际行为研究，创意媒体产品的社会化生产与消费研究等等。除了计算社会科学的构建成为科学发展的重要议程之外，一些与之相关概念也开始进入学术界和社会公众的视野，诸如计算语言学 （computational linguistics）、数据科学(data science）、社会计算 （social computing）、普适计算（ubiquitous computing）、大数据（big data）、可视化 （visualization）、数据新闻学 (data journalism)、计算广告学 (computational advising)。 关于计算传播学的整体学科的体系建构主要基于以下诱因： 复杂网络科学理论的发展和推动。Lazer等学者2009年在《科学》[1]杂志上发表了题为《计算社会科学》（Compuational social science）的文章,在这篇论文当中，计算社会科学的概念被正式提出。Lazer等人强调了大规模的数据收集和数据分析以及网络科学视角对于计算社会科学扮演者至关重要的作用，提出计算社会科学研究可以帮助研究者揭示个体和群体行为的模式。 多主体建模和计算机模拟。多主体建模是一种计算机模拟（或仿真）的方法，通过计算机构建社会系统和在其中互动的主体(agent)，并为主体间的互动指定简单的规则。多个主体之间通过互动“自下而上的”演化出特定的行为模式，被普遍认为是研究复杂自适应系统的一个有效途径。多主体建模的研究方法最早起源于冯·诺依曼的元胞自动机[2]（Neumann\u0026Burks，1966)，而对于传播研究，多主体建模被越来越应用于舆论动力学。 多主体建模是一种计算机模拟（或仿真）的方法。通过计算机构建社会系统和在其中互动的主体（agent），并为主体间的互动指定简单的规则。多个主体之间通过互动而“自下而上的”演化出特定的行为模式。 大规模的人类传播数据挖掘。 2007年，网络科学的重要研究者D. Watts在《自然》[3]杂志上发表了题为《一个二十一世纪的科学》的论文。Watts认为社会科学将成为在二十一世纪获得重要发展的研究领域，其主要原因来源于互联网大数据的使用和网络科学视角。 作为人类行为的“数字化指纹”（digital fingerprint）——沉淀在社交网络的数据使得研究者可以以非介入式的旁观者视角“观察”传播过程，得到更为确实可信的研究结果（Golder \u0026 Macy，2014）。电子化的数据痕迹反映出个人和群体行为规律可以改变我们对个人生活、组织机构及至社会的认知。[2] ","date":"2016-04-25","objectID":"/computational-communication/:2:1","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"1.2 前沿研究 从2009年之后，关于计算社会科学的研究不断增多，其引用数量也相应增长。为了系统地梳理关于计算社会科学的相关文献，《计算传播学导论》一书中采用“computational social science”作为关键词在web of science的数据库中检索，总共发现321篇相关文献。为了展现相关研究的主要引用文献，本文分析了计算社会科学文献的引文网络（如图1所示）。由引用网络可以观察到，该网络具有一个链接紧密的组元（component），关于计算社会科学的研究已经成为一个相对统一的研究领域。 图一 计算社会科学的文献引用参考网络 从被引用的期刊和文献而言，前十名的期刊主要来自综合类的期刊（如《科学》、《自然》等期刊）、社会学、计算机科学、心理学和物理学等学科，值得注意的是这些期刊是整个科学领域最重要的期刊，因此展现了计算社会科学的跨学科特点和吸引力（见表格1）。 表一 被引用数量排名前列的学术期刊 类别 ｜ 期刊 ｜ 引用次数 综合 ｜ SCIENCE, 1997, SCIENCE, V, P ｜ 120 综合 NATURE, 1998, NATURE, V, P 120 综合 P NATL ACAD SCI USA, 2002, P NATL ACAD SCI USA, V, P 89 社会学 Am J SOCIOL, 1981, AM J SOCIOL, V, P 46 计算机 Lect NOTES COMPUT SC, 1995, LECT NOTES COMPUT SC, V, P 35 心理学 Psychol REV, 1956, PSYCHOL REV, V, P 34 社会学 J MATH SOCIOL, 1994, J MATH SOCIOL, V, P 34 物理学 Phys REV E, 1999, PHYS REV E, V, P 33 计算机 Commun ACM, 1995, COMMUN ACM, V, P 32 社会学 Soc NETWORKS, 1986, SOC NETWORKS, V, P 29 表格 2 被引用数量前十名的文献 类别 期刊 引用次数 网络科学 Lazer D, 2009, SCIENCE, V323, P721 26 多主体建模 Axelrod R, 1997, COMPLEXITY COOPERATI, V, P 22 网络科学 Wasserman S, 1994, SOCIAL NETWORK ANAL, V, P 17 多主体建模 Epstein JM, 1996, GROWING ARTIFICIAL S, V, P 15 多主体建模 Schelling TC, 1971, J MATH SOCIOL, V1, P143 12 网络科学 Watts DJ, 1998, NATURE, V393, P440 10 多主体建模 Gilbert N, 2008, AGENT BASED MODELS, V, P1 10 多主体建模 Gilbert N, 2005, SIMULATION SOCIAL SC, V, P 10 网络科学 Barabasi AL, 1999, SCIENCE, V286, P509 9 网络科学 Albert R, 2002, REV MOD PHYS, V74, P47 9 ","date":"2016-04-25","objectID":"/computational-communication/:2:2","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"1.3 相关思考 再比如说，数字、文字和自然语言一样，都是信息的载体，它们之间原本有着天然的联系。香农博士提出的信息熵不仅是对于信息的量化度量，也是整个信息论的基础，它对于通信、数据压缩、自然语言处理都有很强的指导意义。 如果将描述当下社会形态的后喻文化的特质引申泛化到不同学科的交流之间，我们同样可以发现学科反哺在计算传播学的学科发展过程也不同程度地存在着。 由于不同领域的研究范式和关注点的不同，如果没有一个信息传播可计算的理论框架领域，多个理论对于信息传播的研究是碎片化的，同一个科学问题在不同领域的研究成果也无法相互借鉴。解决这一问题的可能方式是融合多个学科的力量，为信息传播再造一个研究框架，即计算传播学。 但同时我们也应该清楚：并非所有社会科学领域的研究对象都可以清晰地量化，对于数学模型的滥用也可能产生不良的负面效果。正如Jerome Kagan在其著作《三种文化：21世纪的自然科学、社会科学和人文学科》指出，过度依赖数学模型的滥用会使得研究者沉浸在种种自负的迷宫和无用的符号中， 要求模型清晰性的代价是对复杂系统尽可能地简化，最终缺失了严格忠于实际存在现象的精神。 ","date":"2016-04-25","objectID":"/computational-communication/:2:3","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"2.经典传播学理论的深化和扩展：可计算性 ","date":"2016-04-25","objectID":"/computational-communication/:3:0","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"2.1从两级传播到多级再到分散和聚合 网络科学对社会关系进行运算，借用统计物理的方法，很快发现复杂网络（例如，大规模的社会网络就是一种复杂网络）具有明显的小世界特征(Watts \u0026 Strogatz, 1998)和无标度特征(Barabási \u0026 Albert, 1999)。 关于社会关系的无标度性，其基本观点是：这也符合二八开马太定律：由少数主导信息传播。比如说2016年初的携程“假机票”风波:除去传播深度，传播走势，引发负面情绪等方面的不同外，传播层级、转发峰值、影响人群等，还受到一个重要的因素影响，那就是意见领袖，或者称“引爆点”。 图2《数据分析：两条微博给携程带来的不同影响》 人们之所以关注或转发评论，一个重要的因素就是信息的价值，同时也与关注对象的本身特性有关。但是在信息传播网络中，受众与意见领袖之间的关系和规则，只有当意见领袖为受众利益服务或与其他连接节点有利益和控制关系的时候，意见领袖或者说中心节点才有权威性，才能成为中心节点。 被转发次数（Re-tweet influence）以及被提及次数（Mention influence）也可用来度量节点的影响力。表示了节点提供有价值的内容的能力。 ","date":"2016-04-25","objectID":"/computational-communication/:3:1","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"2.2基于关系的传播学视角研究 2009年，Facebook在其在线广告系统中引入了基于社会关系的定向方式，弥补了传统的客户定位数据如年龄行动等不易获得、侵犯用户隐私方面的缺陷。基于社会关系的受众定位方法，可以利用用户网络关系直接寻找与已知目标网络距离最近的用户。 ","date":"2016-04-25","objectID":"/computational-communication/:3:2","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"2.3质化研究：内容分析与文本挖掘 2014年皮尤研究中心发布报告称，发现Twitter上的主要讨论会话有六种场景结构：（1）polarized crowd（2）tight crowd（3）brand clusters（4）community clusters（5）broadcast network（6）support network。[5] 来源：The six types of conversations on Twitter， Washington Post，February 20, 2014 2015年12月，学者刘知元，张乐等人也在期刊《中国科学》上发表社会媒体处理专题论文《中文社交媒体谣言统计语义分析》，以上发现和定义引入都是在社交传播网络上一次内容分析法和语义分析建模的典型实践案例。 ","date":"2016-04-25","objectID":"/computational-communication/:3:3","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"3. 总结 “货币使得经济学具有可计算性，实验使得心理学获得可计算性，比特使得计算机科学具有了可计算性，基因使得生物学具有可计算性。”尽管整体架构仍在酝酿中，但毫无疑问，在可预见的未来，伴随着社会计算以及机器学习等新兴研究范式的渗透引入，更加欣欣向荣。 ","date":"2016-04-25","objectID":"/computational-communication/:4:0","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["专业学习"],"content":"4.参考文献 [1]Lazer et al (2009) Compuational social science. Science. V323. 6 Feb 2009 [2]1966. 《自复制自动机理论》(Theory of Self-Reproducing Automata), Burks, A. W., ed., University of Illinois Press. ISBN 978-0-598-37798-2. [3]D. Watts, A twenty-first century science. Nature 445, 489 (2007). [4]林聚任.社会网络分析：理论、方法与应用[M].北京：北京师范大学出版社，2009.3.4 [5]王成军.计算传播学：作为计算社会科学的传播学[J].《中国网络传播研究》2014年00期：193-194 [6]沈浩，杨璇，杨一冰.传播学研究新思路：复杂网络与社会计算[J].科研信息化技术与应用2014, 5(2): 27-33 [7]沈浩，社会网络分析——Social Network Analysis[J/0L].DataInsight http://shenhaolaoshi.blog.sohu.com/136119138.html [8]Andrea Peterson.The six types of conversations on Twitter，Washington Post，February 20, 2014 [9]刘知远,张乐,涂存超,孙茂松,中文社交媒体谣言统计语义分析[J].《中国科学》2015年第45卷第12期：1536-1546 [10]王成军，计算传播学的研究视野，http://www.aiweibang.com/yuedu/62792519.html ","date":"2016-04-25","objectID":"/computational-communication/:5:0","tags":["传播学"],"title":"计算传播学：传播学研究新视角","uri":"/computational-communication/"},{"categories":["电影"],"content":" 前言 多年前的旧文重新搬运回来，没想到竟然被人偷天换日改了个标题，连错别字和病句一个字都没改就登在某浙的一所理工大学的校园网，也是醉了… 奉劝某些喜欢偷窃的人，好自为之。 雪国列车里狭窄逼仄如同产道的的车厢场景原本注定是要大放异彩的，而事实上，在影片的前半段也确实如此：单机游戏闯关般的情节环环相扣，悬念此起彼伏，叙事干脆利落之余也不忘调侃，总会有几个镜头让人会心一笑。 电影前半部分尿点并不多，但是奉导在之后表现得似乎有些“力不从心”和“水土不服”，感觉并不能完全承载原本构思宏大的脚本设定：先前硕果仅存的黑色幽默基本上可以说是冰消雪融，完全不见踪影。而一直竭力铺设的人物矛盾和冲突并没有很好地展现和爆发出来，看似开放式的结尾收束起来最终也没能让人眼前一亮，反而有种莫名落入俗套之感，这都导致了整部影片最终完成度明显低于个人的心理预期。 而也许是受限于原著文本的设定，特别是在关于如何构建一个完整的生态循环系统的问题上，《雪国列车》也没有能够给出一个很好的答案。如果说列车上的能量供给还能说是仰仗“永动机”的话，那么在这43.8万公里的漫长旅途中，在这头尾不接的车厢里，是如何实现包括食物、饮用水等在内的物质循环利用呢？而反派一直宣传的“ 每个人都有自己的位置，人生来就要各司其职 ”的精神内核——位置和平衡理论，则表现得过于直白反而流于形式。此外，影片不时穿插出现一些比如说像是威权统治下的社会“零道德”状态的政治影射，大都也只是停留在浅谈辄止，而并非剧情主线内核。 但无论如何，瑕不掩瑜，至少看在精致如同炫技般的反乌托邦设定还有奉俊昊平均水准之上的导演技巧，《雪国列车》还是对得起票价。而单纯把它当做一部科幻动作片来看或者说怀着对奉导的盲目崇拜而走进影院的观众们甚至还是能收获某些惊喜的。 只是感觉上，有点浪费原作的好设定就是了。 ","date":"2015-10-02","objectID":"/snowpiercer/:0:0","tags":["观后感","韩国"],"title":"雪国列车","uri":"/snowpiercer/"},{"categories":null,"content":"FixIt 主题的离线缓存页面","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"},{"categories":null,"content":"FixIt 主题的友链模板 Demo","date":"0001-01-01","objectID":"/friends/","tags":null,"title":"朋友们的友情链接","uri":"/friends/"},{"categories":null,"content":" 添加你的网站  等待添加中！ ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"朋友们的友情链接","uri":"/friends/"}]